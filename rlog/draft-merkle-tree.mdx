---
title: 'Vac 101 - Climbing Merkle Trees - An Introduction'
date: 2024-11-01 12:00:00
authors: marvin
published: false
slug: climbing-merkle-trees
categories: research

toc_min_heading_level: 2
toc_max_heading_level: 4
---

In this post, we introduce a crucial data structure used throughout web3.

<!--truncate-->

## Introduction

A large amount of data is swapped between users on a blockchain in the form of transactions.
Over the entire lifespan of a blockchain,
the storage space required to maintain a copy of every transaction becomes untenable for most users.
However, the integrity of a blockchain relies on a large pool of users that can validate the blockchain's history to its present state.
The data representing the blockchain's state is compressed.
This compression addresses the issue of scale that would greatly restrict the pool of users.

Data compression alone is not the end goal.
As mentioned, it is essential for users to beable to validate the blockchain's history.
The proble of compression and validation was solved by Bitcoin by the use of Merkle trees.
Merkle trees were first by Ralph Merkle in his dissertation (TODO-citation).
Merkle trees is a data structure that compresses a digest of data to a constant size while still providing a method for proving membership of elements of the digest.

## Tree structure

TODO
A tree is a mathematical structure consisting of 

A tree is a a special mathematical structure  TODO


### Binary Trees

A binary tree is a tree in which each node has at most two children.
Binary trees are commonly used in practice.

A tree 

## Merkle Trees

A Merkle tree is a specialized tree in which each of its nodes contain the evaluation of a hash function.
Merkle trees are usually taken to have a binary tree structure.
As such, the presentation we provide in this section will be in binary form.

### Construction
In this section we show how Merkle tree is constructed.
In particularly, we demonstrate how a Merkle tree compresses a digest $D$.
Suppose that the digest $D$ consists of $2^n$ entries;
we assume that the digest $D$ has this many entries since a Merkle tree is a binary tree.
Additionally, each digest can be padded to ensure that $D$ has the desired number of entries.

Each leaf of the Merkle tree contains the hash of a digest entry.
Each parent node contains the hash of the concatenation of their children nodes.
Through this iterative construction, we reach the root of the tree.
The value contained in the root node is called the root hash.
The root hash is the compression of the digest $D$.

TODO: diagram of a Merkle tree.

Each node in the Merkle tree computed by taking a hash.
Since a binary tree with $2^n$ leaves has $2^{n+1}-1$ nodes,
then we need to evaluate $2^{n+1}-1$ hashes to construct the Merkle tree.

### Title for security?

Now, we've seen that a large quantity of data can be compressed to a single hash value.
Couldn't a clever party find another digest that yields a Merkle tree with the same root hash?
If so, that would render Merkle trees useless for blockchains.
Afterall, this would compromise the ledger.
Merkle trees are quite secure.
In fact, Merkle trees can be used to both bind and hide their digest.

The Merkle tree is able to bind the digest by the one of properties of hash functions (see our previous Vac-101 for [information on hash functions](https://vac.dev/rlog/vac101-fiat-shamir#hash-functions)).
Specifically, a hash function is collision resistant; it is difficult for a malicious party to find two values that hash to the same value.
This collision resistance property, essentially, fixes the input to each leaf and into their parents, parents' parents, and so on.

In certain applications,
it may be desirable for digest for the Merkle tree to be kept confidential.
This is achieved by the preimage resistant propery of hash functions.
A hash function is preimage resistant provided that it is difficult reverse the hashing operation. 
It would be necessary for a malicious party to find preimages to each node starting from the root node to determine original digest.

Now, we see that Merkle trees are secured structures that are tamper resistant.

### Proof of Membership

TODO

 The root of a Merkle
 tree is called the root hash. 
We note that a
 binary tree with $n$ leaves has $\log(n)+1$
 layers. The 0th layer of the
 tree consists of leaves and the
 $\log(n)$th layer consists of the root hash.

Let $H$ be a secure hash function.
Suppose $L := \{\ell_0, \dots, \ell_{n-1}\}$ is an
ordered set of data with
$n = 2^k$. Merkle
trees are constructed from the leaves
to the root.
The $i$th leaf of the Merkle tree for $L$ contains the hash
$H(\ell_i)$.
 The $i$th node in layer $j$, for $j \geq 1$, is
 the concatenated hash of the values in the $(2i)$th and
 $(2i+1)$th nodes in layer $(j-1)$.
 Figure
\ref{fig:merkle} illustrates the structure of a
Merkle tree for $n=8$.

Since 
a binary tree with $n$ leaves
has $2n-1$ nodes then $2n-1$ hashes are computed 
in the construction of a Merkle tree.
So, provided the hash $H$ can be evaluated in constant time regardless
of the input, a Merkle
tree can be generated in $O(n)$. 

\input{Prereq/Commit/Merkle_Tree/merkle_diagram.tex}


Suppose that $T$ is a Merkle tree with root hash $h$
and $n = 2^k$ leaves. For $i \in [n]$, the list
$\bc \in \left(\{0,1\}^*\right)^{\log(n)}$ is the
path for $\ell_i$ provided:
the $j$th entry of $\bc$ is the sibling node for the node in layer $j$ that can be computed using $\bc[0],\dots,\bc[j-1]$, and $\ell_i$.

Suppose that the Prover gives the Verifier
the $i$th entry of $L$.
Define $h_0 := H(\ell_i)$. Since the Verifier
knows $n$ and $i$, the Verifier can
determine whether
$h_0$'s sibling, $\bc[0]$, is a left or right
sibling. 
That is, the Verifier can correctly compute the parent of $h_0$ and $\bc[0]$
which is either
$h_1 = H(h_0 \mid\mid \bc[0])$ or 
$h_1 = H(\bc[0] \mid \mid h_0)$. Similarly,
for $1 \leq j \leq \log(n)$, the Verifier
can correctly select
$h_j = H(h_{j-1} \mid \mid \bc[j-1])$ or
$h_j = H(\bc[j-1] \mid \mid h_{j-1})$ as the
label for the parent node of
$h_{j-1}$ and $\bc[j-1]$. Note that
$h_{\log(n)}$ should be the root hash.
See Figures \ref{fig:path_1} 
and \ref{fig:path_2} for examples
of appropriate paths.
The Verifier accepts the Prover's claim that
$\ell_i \in L$ provided $h \stackrel{?}{=} h_{\log(n)}$.
Notice that the Verifier computes
$\log(n)+1$ hashes to check $h \stackrel{?}{=} h_{\log(n)}$. The algorithms to use Merkle Trees as a commitment scheme are:

\input{Prereq/Commit/Merkle_Tree/merkle_path.tex}

\begin{itemize}
\item $\pp \leftarrow \gen(1^\lambda)$: Selects a secure hash function $H$, and outputs $\pp = H$.
\item $\cC \leftarrow \commit(\pp,\bx, \br)$:
Constructs the Merkle Tree for $\bx$, and outputs the root hash as $\cC$
\item $b \in \{\acc, \rej\} \leftarrow \open(\pp,\cC,\bx)$: Outputs $\acc$ provided
$\cC$ is the root hash of the Merkle tree generated by the public parameters $\pp$ and $\bx$; otherwise outputs $\rej$.
\end{itemize}

We note that Merkle trees fail to be
homomorphic.

\begin{thm}
Merkle tree forms a commitment scheme.
\end{thm}
\begin{proof}
Let $T$ be a Merkle tree for either
$\bx_0$ or $\bx_1$. Given a PPT adversary
$\cA$ that possesses $\bx_0$ and
$\bx_1$, $\cA$ cannot determine whether
the root hash of $T$ is associated to
$\bx_0$ or $\bx_1$. For $\cA$ to construct
one of the Merkle trees requires $O(n) = O(2^v)$ hashes. Thus, Merkle trees satisfies hiding.

Suppose that an algorithm $\cA$ can violate
binding. That is, $\cA$ can find
two distinct $\bx_0$ and $\bx_1$ that
share form a Merkle tree with the same 
Merkle root. Let
$T_0$ and $T_1$ denote the Merkle
trees for $\bx_0$ and $\bx_1$, respectively.

Now, let $i \in [\log(n)+1]$ be
the maximum integer so that the trees
$T_f$ and $T_g$ differ for at least one
node in layer $i$. Since 
$\bx_0$ and $\bx_1$ are distinct, then
$\bx_0[k] \neq \bx_1[k]$ for some $k \in [n]$. That is, at least one leaf is different
between $T_0$ and $T_1$.
Additionally, since $T_0$ and
$T_1$ have the same root then
 $0\leq i < \log(n)$.
Suppose that the Merkle trees $T_0$ and $T_1$ differ at either the $2k$th node or node $2k+1$th in layer $i$.
Let $N_h(i,j)$ denote the value of node $j$ in layer $i$ for the Merkle tree generated by $\bx_h$.
Since the trees $T_0$ and $T_1$ are either different at node $2k$ or node $2k+1$ in layer $i$, then we have
either
\[
N_0(i, 2k) \neq N_1(i, 2k)
\text{ or }
N_0(i, 2k+1) \neq N_1(i, 2k+1).
\]
Also, since $i$ is the maximum
layer that nodes may differ between
trees $T_0$ and $T_1$, then
\[
H(N_0(i, 2k) || N_0(i,2k+1)) =
H(N_1(i, 2k) || N_1(i, 2k+1)).
\]
However, since $H$ is a secure hash function
it is infeasible to find collisions.
Thus, it is infeasible for such an algorithm
$\cA$ to exist. Therefore, Merkle tree
satisfies binding.
\end{proof}

## Extensions of Merkle Trees

Merkle trees can be extended in multiple ways.
In this section, we will explore a select few of these extensions.

### Sparse Merkle Trees



Let $n$ denote the number of bits that a leaf can possible possess. This corresponds with the output of the hash function that is used. This also means that our tree can have at most $2^n$ leaves.

Let $\mathsf{null}$ denote the value used to represent no-entry. We can treat a SMT as a 'full' Merkle tree in which leaves without an entry contain $\mathsf{null}$. A SMT is sparse, then it is unlikely for filled leaves to cluster together. As such, it is efficient to maintain a list of values:
\begin{align}
d_0 := \mathsf{Hash(null)},\\
d_1 := \mathsf{Hash(d_0 || d_0)},\\
d_2 := \mathsf{Hash(d_1 || d_1)},\\
\vdots\\
d_{n-1} := \mathsf{Hash(d_{n-2} || d_{n-2})}.
\end{align}
Each of the values $d_i$ represents the hash of a Merkle tree with $2^i$ leaves in which each leave contains $\mathsf{null}$. By using these values, we can shorten the time that it takes to generate the SMT.

To generate a deterministic leaf location for a given data $d$, we can use the $\mathsf{Hash}$ by computing $\mathsf{Hash(0 || d)}$. The value 0 can be replaced with any constant as long as it is used for all location calculations.

### Proof of Non-membership

In the first [Vac-101](https://vac.dev/rlog/vac101-membership-with-bloom-filters-and-cuckoo-filters), we examined Bloom and Cuckoo filters that could be used for proof of membership and non-membership.
However, the proof of membership may result in false-positives due to collisions.
This would affect non-membership proofs as well.
Sparse Merkle trees can be adapted to provide greater assurance that a given piece of data is not a member of the digest.

We require that the leaves of a sparse Merkle tree to be sorted.
This requirements allows sparse Merkle tree to support non-membership proofs.
We refer to such a tree as indexed sparse Merkle tree.
(TODO: citation for this idea)

How do we sort the leaves?
The sorting mechanism of data can be arbitrarily chosen.
However, it is essential that there are no gaps in the ordering.
That is, it must be known what the maximal number of elements that could ever exist in the digest is.
A simple method for this is to use a hash function to provide fingerprints to the data.
Each hash using either SHA-256 or Keccak has 256-bits.
Our entire digest could consist of a maximum of $2^{256}$ entries.
This assumes that our digest does not contain collisions.

The fingerprint of a piece of data $\ell$ indicates which leaf of the indexed sparse Merkle tree it is contained in. This means that a non-membership of $\ell$ in the indexed sparse Merkle tree becomes a matter of proving that the empty entry is contained in $\ell$'s location. 

We note that it is critical for the sparse Merkle tree to be sorted. 
Otherwise, an entity could append the entry $\ell$ to a different location to produce proofs that contradictory prove both membership and non-memberhip.
The requirement that the tree is sorted can be too strong of an assumption in centralized cases.
However, if any party can construct the tree on their own (as in decentralized settings) then the contradictory proofs cannot be generated.

### Tree Ranges (?)

TODO
### Verkle Trees
A proof of membership grows in length as the Merkle tree grows.
The most obvious approach to remedy this scalability issue is to use Merkle trees where each node has more than 2 children.
However, as we saw earlier, this does not fix the issue.
An alternate approach is to use a different data structure: [Verkle trees](https://math.mit.edu/research/highschool/primes/materials/2018/Kuszmaul.pdf).
A Verkle tree replaces hash functions with polynomial commitments.
We will explore Verkle trees is a future Vac 101 edition.

## References


- [Verkle Trees](https://math.mit.edu/research/highschool/primes/materials/2018/Kuszmaul.pdf)